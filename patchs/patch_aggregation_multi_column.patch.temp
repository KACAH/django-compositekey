Index: django/db/models/sql/aggregates.py
===================================================================
--- django/db/models/sql/aggregates.py	(revision 17100)
+++ django/db/models/sql/aggregates.py	(working copy)
@@ -76,6 +76,33 @@
     def as_sql(self, qn, connection):
         "Return the aggregate, rendered as SQL."
 
+        # todo: he hato to do the same of the IN clause using the CONCAT inside the Aggregate
+        # so we have to change the params to obtain a SQL valid function
+
+        class AggregateMulticolumn(object):
+            def __init__(self, column, aliases=[]):
+                self.columns = [tuple(aliases+[c]) for c in column.columns]
+
+            def append(self, obj):
+                raise Exception("Absurd situation", obj)
+
+            def as_sql(self, qn, connection):
+                return "||".join(['.'.join([qn(c) for c in column]) for column in self.columns])
+
+
+
+        if isinstance(self.col, (list, tuple)):
+            # now we are ignoring the rest of the key using only the first column of the key
+            col = []
+            for c in self.col:
+                if hasattr(c, "columns"):
+                    col = AggregateMulticolumn(c, aliases=col)
+                else:
+                    col.append(c)
+            self.col = col
+        else:
+            self.col = AggregateMulticolumn(self.col) if hasattr(self.col, "columns") else self.col
+
         if hasattr(self.col, 'as_sql'):
             field_name = self.col.as_sql(qn, connection)
         elif isinstance(self.col, (list, tuple)):
Index: django/db/models/sql/compiler.py
===================================================================
--- django/db/models/sql/compiler.py	(revision 17100)
+++ django/db/models/sql/compiler.py	(working copy)
@@ -389,7 +389,7 @@
         field, target, opts, joins, last, extra = self.query.setup_joins(pieces,
                 opts, alias, False)
         alias = joins[-1]
-        col = target.column
+        col = getattr(target.column, "columns", [target.column])[0] # todo: ordering using only the first column in multicolumns
         if not field.rel:
             # To avoid inadvertent trimming of a necessary alias, use the
             # refcount to show that we are referencing a non-relation field on
Index: django/db/models/sql/query.py
===================================================================
--- django/db/models/sql/query.py	(revision 17100)
+++ django/db/models/sql/query.py	(working copy)
@@ -341,6 +341,12 @@
         if not self.aggregate_select:
             return {}
 
+#        for alias, aggregate in self.aggregate_select.items():
+#            if hasattr(aggregate.source, "is_composite_primarykeys_field"):
+#                print aggregate.field, aggregate.source
+#                print aggregate.field.__dict__, aggregate.source.__dict__
+
+
         # If there is a group by clause, aggregating does not add useful
         # information but retrieves only the first row. Aggregate
         # over the subquery instead.
@@ -641,7 +647,10 @@
         if table not in target:
             target[table] = set()
         for field in fields:
-            target[table].add(field.column)
+            if not hasattr(field.column, "columns"):
+                target[table].add(field.column)
+            else:
+                target[table].update(field.column.columns)
 
 
     def table_alias(self, table_name, create=False):
@@ -1822,7 +1831,12 @@
         """
         Callback used by get_deferred_field_names().
         """
-        target[model] = set([f.name for f in fields])
+        fields_name = [f.name for f in fields if not getattr(f, "not_in_db", False)]
+        for field in fields:
+            if getattr(field, "not_in_db", False):
+                fields_name += [f.name for f in field.fields]
+        
+        target[model] = set(fields_name)
 
     def set_aggregate_mask(self, names):
         "Set the mask of aggregates that will actually be returned by the SELECT"
Index: django/db/models/query_utils.py
===================================================================
--- django/db/models/query_utils.py	(revision 17100)
+++ django/db/models/query_utils.py	(working copy)
@@ -146,6 +146,9 @@
     being replaced with DeferredAttribute objects. The "pk_value" ties the
     deferred attributes to a particular instance of the model.
     """
+    if hasattr(model._meta, "composite_special_fields"):
+        attrs = [attr for attr in attrs if attr not in [f.attname for f in model._meta.composite_special_fields]]
+
     class Meta:
         proxy = True
         app_label = model._meta.app_label
