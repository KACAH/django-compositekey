Index: django/db/models/sql/query.py
===================================================================
--- django/db/models/sql/query.py	(revision 17092)
+++ django/db/models/sql/query.py	(working copy)
@@ -640,7 +640,10 @@
         if table not in target:
             target[table] = set()
         for field in fields:
-            target[table].add(field.column)
+            if not hasattr(field.column, "columns"):
+                target[table].add(field.column)
+            else:
+                target[table].update(field.column.columns)
 
 
     def table_alias(self, table_name, create=False):
@@ -1821,7 +1824,12 @@
         """
         Callback used by get_deferred_field_names().
         """
-        target[model] = set([f.name for f in fields])
+        fields_name = [f.name for f in fields if not getattr(f, "not_in_db", False)]
+        for field in fields:
+            if getattr(field, "not_in_db", False):
+                fields_name += [f.name for f in field.fields]
+        
+        target[model] = set(fields_name)
 
     def set_aggregate_mask(self, names):
         "Set the mask of aggregates that will actually be returned by the SELECT"
Index: django/db/models/query.py
===================================================================
--- django/db/models/query.py	(revision 17092)
+++ django/db/models/query.py	(working copy)
@@ -916,8 +916,9 @@
 
     def iterator(self):
         # Purge any extra columns that haven't been explicitly asked for
+        valid_names = [f.name for f in self.model._meta.local_fields if not getattr(f, "not_in_db", False)]
         extra_names = self.query.extra_select.keys()
-        field_names = self.field_names
+        field_names = [name for name in self.field_names if name in valid_names]
         aggregate_names = self.query.aggregate_select.keys()
 
         names = extra_names + field_names + aggregate_names
Index: django/db/models/query_utils.py
===================================================================
--- django/db/models/query_utils.py	(revision 17092)
+++ django/db/models/query_utils.py	(working copy)
@@ -146,6 +146,9 @@
     being replaced with DeferredAttribute objects. The "pk_value" ties the
     deferred attributes to a particular instance of the model.
     """
+    if hasattr(model._meta, "composite_special_fields"):
+        attrs = [attr for attr in attrs if attr not in [f.attname for f in model._meta.composite_special_fields]]
+
     class Meta:
         proxy = True
         app_label = model._meta.app_label
Index: django/core/serializers/python.py
===================================================================
--- django/core/serializers/python.py	(revision 17092)
+++ django/core/serializers/python.py	(working copy)
@@ -94,7 +94,8 @@
 
             # Handle M2M relations
             if field.rel and isinstance(field.rel, models.ManyToManyRel):
-                if hasattr(field.rel.to._default_manager, 'get_by_natural_key'):
+                if hasattr(field.rel.to._default_manager, 'Deserializer') or \
+                    hasattr(field.rel.to._default_manager, "get_by_natural_key"):
                     def m2m_convert(value):
                         if hasattr(value, '__iter__'):
                             return field.rel.to._default_manager.db_manager(db).get_by_natural_key(*value).pk
Index: django/core/management/commands/dumpdata.py
===================================================================
--- django/core/management/commands/dumpdata.py	(revision 17092)
+++ django/core/management/commands/dumpdata.py	(working copy)
@@ -146,11 +146,11 @@
             for field in model._meta.fields:
                 if hasattr(field.rel, 'to'):
                     rel_model = field.rel.to
-                    if hasattr(rel_model, 'natural_key'):
+                    if hasattr(rel_model, 'natural_key') and rel_model != model:
                         deps.append(rel_model)
             for field in model._meta.many_to_many:
                 rel_model = field.rel.to
-                if hasattr(rel_model, 'natural_key'):
+                if hasattr(rel_model, 'natural_key') and field.rel.to != model:
                     deps.append(rel_model)
             model_dependencies.append((model, deps))
 
